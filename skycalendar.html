<!--Plan: 
make a mockup of the craftersmc calendar ingame, as a website
use a system to calculate each day and it can be infinitely calculated,
each page is 31 days, so page 1 is day 1-31, page 2 is day 32-62, etc
it will calcuate the first 2 pages on load,
a button to go to the next page, onlick it will replace the current page with the next pages
the button will also calculate the next pages, so if you are on page 2, it wll callculate page 3,
page 5, calculate page 6
page 10, calculate page 11
etc
Underneath that calendar, it will show the next upcoming events with timers, like the first page before the json UI calendar ingame
It will show the next upcoming event for each event
Then we will have underneath that the same timer and next 10 calculations as we have already, all in one page. 
This is gonna be hugeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee
anyways i have the new covid variant so im going to sleep bye
-->

<!--This is the AI made prototype we can adapt into our own system, Gemini 2.5 pro-->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CraftersMC Skyblock Calendar</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="css/essential.css" />
    <!--<link rel="stylesheet" href="css/skycalendar.css" />-->
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet" />
    <script src="js/script.js" defer></script>
    <style>
        :root {
            --bg-primary: #111827;
            --bg-secondary: rgba(0, 0, 0, 0);
            --bg-tertiary: rgba(100, 100, 100, 0.5);
            --bg-interactive: #4b5563;
            --border-color: #4b5563;
            --text-primary: #f3f4f6;
            --text-secondary: #9ca3af;
            --accent-color: #007bff;
            --accent-hover: #005bef;
            --highlight-color: #f59e0b;
        }
        
        body {
            font-family: 'Inter', sans-serif;
            background-image: url('Backgrounds/IMG_4500Blurred.webp');
            background-size: cover;
            background-attachment: fixed;
            background-position: center;
            color: var(--text-primary);
            margin: 0;
            padding: 1rem;
        }

        body::after {
            content: "";
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            pointer-events: none;
            z-index: -1;
        }

        .container {
            display: flex;
            flex-direction: column;
            max-width: 1280px;
            margin: 0 auto;
            align-items: center;
        }

        /* Header */
        header {
            text-align: center;
            margin-bottom: 2rem;
            background-color: var(--bg-secondary);
            border-radius: 16px;
            
            padding: 5px;
        }
        header h1 {
            font-size: 2.25rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
        }
        header p {
            font-size: 1.125rem;
            color: var(--text-secondary);
        }

        /* Card styles */
        .card {
            background-color: var(--bg-secondary);
            border-radius: 1rem;
            box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1), 0 4px 6px -2px rgba(0,0,0,0.05);
            border: 2px solid rgba(255, 255, 255, 0.2);
            padding: 1.5rem;
            margin-bottom: 2rem;
            width: 95%;
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }
        
        .card-header h2 {
            font-size: 1.5rem;
            font-weight: 600;
        }
        
        .pagination {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        
        .pagination span {
            font-size: 1.125rem;
            font-weight: 500;
            text-align: center;
            width: 5rem;
        }
        
        
        button:disabled {
            background-color: var(--bg-tertiary);
            opacity: 0.5;
            cursor: not-allowed;
        }
        

        #prev-page-btn:not(:disabled):hover {
            background-color: var(--bg-interactive);
        }
        
        /* Calendar Grid */
        #calendar-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 0.75rem;
        }
        
        .day-cell {
            padding: 0.75rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1), 0 2px 4px -1px rgba(0,0,0,0.06);
            display: flex;
            flex-direction: column;
            height: 8rem;
            transition: transform 0.2s, box-shadow 0.2s;
            background-color: var(--bg-tertiary);
            cursor: pointer;
        }

        .day-cell:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 15px -3px rgba(0,0,0,0.2), 0 4px 6px -2px rgba(0,0,0,0.1);
        }

        .day-cell.current-day {
            outline: 3px solid var(--highlight-color);
        }
        
        .day-cell-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.75rem;
            margin-bottom: 0.25rem;
        }
        
        .day-cell-header .day-season {
            font-weight: 700;
            opacity: 0.8;
        }
        
        .day-cell-header .day-total {
            opacity: 0.6;
        }
        
        .day-cell-body {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            overflow: hidden;
        }
        
        .event-icon {
            font-size: 1.5rem; 
        }

        .event-icons-wrapper {
            display: flex;
            gap: 0.5rem;
            font-size: 1.25rem;
            align-items: center;
        }
        .event-name {
             margin-top: auto; 
             font-size: 0.75rem; 
             font-weight: 600;
        }
        .multiple-events-indicator { 
            font-size: 0.8rem; 
            font-weight: bold; 
            color: var(--text-secondary); }

        /* Upcoming Events */
        #upcoming-events-list { 
            display: flex; flex-direction: column; gap: 1rem; 
        }
        .event-timer-item { 
            display: flex; 
            align-items: center; 
            justify-content: space-between; 
            background-color: rgba(55, 65, 81, 0.5); 
            padding: 0.75rem; 
            border-radius: 0.5rem; 
        }
        .event-timer-info {
             display: flex; 
             align-items: center; 
             gap: 0.75rem; 
        }
        .event-timer-info .event-name {
             font-weight: 600; 
        }

        .event-timer-info .event-subtext {
             font-size: 0.75rem; 
             color: var(--text-secondary);
             display: flex;
             align-items: center; 
             margin: 8px 0;
        }
        .event-timer-countdown {
             font-family: monospace; 
             font-size: 1.125rem; 
             color: var(--highlight-color); 
        }
        

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(17, 24, 39, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
        }

        .modal-overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background-color: var(--bg-secondary);
            backdrop-filter: blur(10px);
            padding: 2rem;
            border-radius: 1rem;
            width: 90%;
            max-width: 500px;
            position: relative;
            transform: scale(0.95);
            transition: transform 0.3s;
        }

        .modal-overlay.visible .modal-content {
            transform: scale(1);
        }

        .modal-close-btn {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1.5rem;
            cursor: pointer;
        }

        .modal-header h3 { 
            font-size: 1.5rem; 
            font-weight: 600; 
            margin: 0; 
        }
        .modal-header p { 
            color: var(--text-secondary); 
            
        }
        .modal-body { 
            margin-top: 1.5rem; 
        }
        .modal-body h4 { 
            font-weight: 600; 
            border-bottom: 1px solid var(--border-color); 
            padding-bottom: 0.5rem; 
            margin: 0 0 1rem 0; 
        }
        .modal-event-list { 
            list-style: none; 
            padding: 0; 
            margin: 0; 
            display: flex; 
            flex-direction: column; 
            gap: 0.75rem; 
        }
        .modal-event-item { 
            display: flex; 
            align-items: center; 
            gap: 1rem; 
        }
        .modal-event-item .event-icon { 
            font-size: 1.75rem; 
        }

        .modal-event-item span {
            display: flex;
            align-items: center;
            gap: 4px
        }
    </style>
</head>
<body>
    
  <div class="top"></div>
  <div class="sidebar" id="sidebar"></div>
  <div id="sidebar-overlay" onclick="toggleSidebar()"></div>
  <div class="gap"></div>
  <br>


    <div class="container">
        <header>
            <h1>Skyblock Calendar</h1>
            <p id="current-date-info">Loading current date...</p>
        </header>

        <div class="card">
            <div class="card-header">
                <h2>Calendar - Year <span id="calendar-year">1</span></h2>
                <div class="pagination">
                     <button id="prev-page-btn">&lt; Prev</button>
                    <span>Page <span id="calendar-page">1</span></span>
                    <button id="next-page-btn">Next &gt;</button>
                </div>
            </div>
            <div id="calendar-grid"></div>
        </div>

        <div class="card">
            <h2 style="border-bottom: 1px solid var(--border-color); padding-bottom: 0.75rem; margin-bottom: 1rem;">Upcoming Events</h2>
            <div id="upcoming-events-list"></div>
        </div>
    </div>

    <div id="day-modal" class="modal-overlay">
        <div class="modal-content">
            <button id="modal-close-btn" class="modal-close-btn">&times;</button>
            <div class="modal-header">
                <h3 id="modal-ingame-date"></h3>
                <p id="modal-real-date"></p>
                <p id="modal-countdown-to-day" style="color:var(--highlight-color);font-family:monospace;margin-top:0.5em;"></p>
            </div>
            <div class="modal-body">
                <h4 id="modal-events-title">Events</h4>
                <ul id="modal-event-list"></ul>
            </div>
        </div>
    </div>
<div id="footer"></div>
    <script>
        /**
         * CALENDAR ENGINE
         * This object contains all pure calculation logic, free of any DOM manipulation.
         * It can be moved to a Web Worker file in the future.
         */
        
        const CalendarEngine = {
            
            // basic variables and some offsets
            START_OF_TIMES: 1648800000, //secs
            TIME_MULTIPLIER: 72,
            SEASON_LENGTH: 93, // in days obv
            YEAR_LENGTH: 4,
            DAYS_PER_YEAR: 372,
            DAYS_PER_PAGE: 31, 
            MINUTES_PER_SKYBLOCK_DAY: 20,
            SEASON_SPRING: 0, SEASON_SUMMER: 1, SEASON_AUTUMN: 2, SEASON_WINTER: 3,
            
            LEGENDARY_PATTERN: ['elephant','giraffe','tiger','lion','monkey'],
            LEGENDARY_ICONS: { 'elephant':'<img src="img/pets/Elephant_Pet.webp" style="height:30px;width:auto;margin:4px;">',

            'giraffe':'<img src="img/pets/Giraffe_Pet.webp" style="height:30px;width:auto;margin:4px;">',

            'tiger':'<img src="img/pets/300px-Tiger_pet.webp" style="height:30px;width:auto;margin:4px;">',

            'lion':'<img src="img/pets/300px-Lion_pet.webp" style="height:30px;width:auto;margin:4px;">',

            'monkey':'<img src="img/pets/Monkey_pet.webp" style="height:30px;width:auto;margin:4px;">'},
            TRAVELING_ZOO_LEGENDARY_OFFSET: 2,
            pagesDataCache: new Map(),
            SEASON_NAMES: ['Spring', 'Summer', 'Autumn', 'Winter'],
            CropType: ['WHEAT', 'SUGAR_CANE', 'CARROT', 'POTATO', 'MELON', 'PUMPKIN', 'COCOA_BEANS', 'CACTUS', 'MUSHROOM', 'BEETROOT'],
            //const crops = ["Wheat", "Sugar Cane", "Carrot", "Potato", "Melon", "Pumpkin", "Cocoa Beans", "Cactus", "Mushroom", "Beetroot"];
            CROP_ICONS: { 'WHEAT': 'üåæ', 'SUGAR_CANE': 'üéç', 'CARROT': 'ü•ï', 'POTATO': 'ü•î', 'MELON': 'üçâ', 'PUMPKIN': 'üéÉ', 'COCOA_BEANS': 'ü´ò', 'CACTUS': 'üåµ', 'MUSHROOM': 'üçÑ', 'BEETROOT': 'üçì' },
            // farming contest seed algorithm from craftersmc official calendarjs
            Random: (function() {
                const MUL = 0x5DEECE66Dn;
                const ADD = 0xBn;
                const MASK48 = (1n << 48n) - 1n;
    
                return class JavaRandom {
                    constructor(seedVal) {
                        this.seed = 0n;
                        this.setSeed(Number(seedVal) || 0);
                    }
                    setSeed(seedVal) {
                        const s = BigInt(seedVal);
                        this.seed = (s ^ MUL) & MASK48;
                    }
                    next(bits) {
                        this.seed = (this.seed * MUL + ADD) & MASK48;
                        return Number(this.seed >> (48n - BigInt(bits)));
                    }
                    nextInt(bound) {
                        if (bound === undefined) return this.next(32) | 0;
                        if (!Number.isInteger(bound) || bound <= 0) throw new RangeError('bound must be positive integer');
                        if ((bound & (bound - 1)) === 0) {
                            return Math.floor(bound * (this.next(31) / 2147483648));
                        }
                        let bits, val;
                        do {
                            bits = this.next(31);
                            val = bits % bound;
                        } while (bits - val + (bound - 1) < 0);
                        return val;
                    }
                };
            })(),

            // helper to compute which legendary pet a travelling zoo has on a given totalDay
            getTravelingZooLegendaryForDay(totalDay) {
                const daysSinceEpoch = totalDay - 1;
                const seasonsSinceEpoch = Math.floor(daysSinceEpoch / this.SEASON_LENGTH);
                const year = Math.floor(seasonsSinceEpoch / this.YEAR_LENGTH) + 1;
                const season = seasonsSinceEpoch % this.YEAR_LENGTH; // 0..3
                // only valid for summer/winter traveling zoo
                if (season !== this.SEASON_SUMMER && season !== this.SEASON_WINTER) return null;

                // occurrence index (zero-based): per year there are 2 zoos: summer then winter
                const occurrenceIndex = (year - 1) * 2 + (season === this.SEASON_SUMMER ? 0 : 1);
                const idx = (occurrenceIndex + this.TRAVELING_ZOO_LEGENDARY_OFFSET) % this.LEGENDARY_PATTERN.length;
                const name = this.LEGENDARY_PATTERN[idx];
                return { name, icon: this.LEGENDARY_ICONS[name] || '‚ùì' };
            },

            // --- Methods ---
            getPageData(pageNumber) {
                if (!this.pagesDataCache.has(pageNumber)) this.calculatePage(pageNumber);
                return this.pagesDataCache.get(pageNumber);
            },

            preCalculatePage(pageNumber) {
                if (!this.pagesDataCache.has(pageNumber)) this.calculatePage(pageNumber);
            },

            calculatePage(pageNumber) {
                const pageDays = [];
                const startDay = (pageNumber - 1) * this.DAYS_PER_PAGE + 1;
                const endDay = startDay + this.DAYS_PER_PAGE - 1;
                for (let day = startDay; day <= endDay; day++) pageDays.push(this.getDayInfo(day));
                this.pagesDataCache.set(pageNumber, pageDays);
            },
            
            getDayInfo(totalDay) {
                const daysSinceEpoch = totalDay - 1;
                const seasonsSinceEpoch = Math.floor(daysSinceEpoch / this.SEASON_LENGTH);
                const yearsSinceEpoch = Math.floor(seasonsSinceEpoch / this.YEAR_LENGTH);
 
                const year = yearsSinceEpoch + 1;
                const season = seasonsSinceEpoch % this.YEAR_LENGTH;
                const dayOfSeason = daysSinceEpoch % this.SEASON_LENGTH + 1;
                
                const events = [];
                if (daysSinceEpoch % 3 === 0) {
                    events.push({ name: 'Farming Contest', icon: '<img src="assets/farming/Farm-o-Matic.webp" style="width:24px">', type: 'farming', crops: this.getFarmingCrops(Math.floor(daysSinceEpoch / 3)) });
                }
                if (season === this.SEASON_SPRING && (year - 1) % 4 === 0) {
                    events.push({ name: "Season of the Pig", icon: '<img src="img/100px-Shiny_Orb.webp" style="width:30px">' });
                }
                if ((season === this.SEASON_SUMMER && dayOfSeason <= 3) || (season === this.SEASON_WINTER && dayOfSeason <= 3)) {
                    // attach legendary info for this travelling zoo occurrence
                    const legendary = this.getTravelingZooLegendaryForDay(totalDay) || { name: 'Unknown', icon: 'üêò' };
                    events.push({ name: "Traveling Zoo", icon: legendary.icon, legendaryName: legendary.name });
                }
                 if (season === this.SEASON_WINTER && dayOfSeason >= 91) {
                     events.push({ name: "New Year Celebration", icon: '<img src="img/Enchanted_Cake.webp" style="width:30px">' });
                 }
 
                 return { totalDay, year, season: this.SEASON_NAMES[season], dayOfSeason, events };
            },

            getFarmingCrops(eventId) {
                const GOLDEN = 0x9E3779B97F4A7C15n;
                const seed64 = (BigInt(eventId) ^ GOLDEN) & ((1n << 48n) - 1n);
                const seed48 = Number(seed64);
                const rng = new this.Random(seed48);
                const arr = this.CropType.slice();
                for (let i = arr.length - 1; i > 0; i--) {
                    const j = rng.nextInt(i + 1);
                    const tmp = arr[i];
                    arr[i] = arr[j];
                    arr[j] = tmp;
                }
                return arr.slice(0, 3);
            },
            
            getCurrentTimeData() {
                const realSecondsSinceEpoch = (Date.now() / 1000) - this.START_OF_TIMES;
                const skyblockSeconds = realSecondsSinceEpoch * this.TIME_MULTIPLIER;
                const skyblockDecimalDays = skyblockSeconds / 86400;
                
                const daysSinceEpoch = Math.floor(skyblockDecimalDays);
                const seasonsSinceEpoch = Math.floor(daysSinceEpoch / this.SEASON_LENGTH);
                const currentYear = Math.floor(seasonsSinceEpoch / this.YEAR_LENGTH) + 1;
                const currentSeason = seasonsSinceEpoch % this.YEAR_LENGTH;
                const currentDayOfSeason = daysSinceEpoch % this.SEASON_LENGTH + 1;

                return {
                    currentYear, currentSeason, currentDayOfSeason, skyblockDecimalDays,
                    currentSkyblockDay: daysSinceEpoch + 1,
                    currentDayOfYear: (currentSeason * this.SEASON_LENGTH) + currentDayOfSeason
                };
            },

            getUpcomingEventsData() {
                const time = this.getCurrentTimeData();
                const upcoming = [];

                // Farming Contest
                const nextContestDay = Math.floor(time.currentSkyblockDay / 3) * 3 + 1;
                upcoming.push({ name: "Farming Contest", icon: '<img src="assets/farming/Farm-o-Matic.webp" style="width:24px">', type: 'farming', nextDay: nextContestDay > time.currentSkyblockDay ? nextContestDay : nextContestDay + 3, crops: this.getFarmingCrops(Math.floor(nextContestDay/3))});

                // Season of the Pig
                let nextPigYear = Math.ceil(time.currentYear / 4) * 4 + 1; //+1 for accuracy
                if(time.currentYear > nextPigYear || (time.currentYear === nextPigYear && time.currentSeason > this.SEASON_SPRING)) nextPigYear += 4;
                upcoming.push({ name: "Season of the Pig", icon: '<img src="img/100px-Shiny_Orb.webp" style="width:30px">', nextDay: ((nextPigYear - 1) * this.DAYS_PER_YEAR) + 1});

                // New Year
                let nextNewYearDay = ((time.currentYear -1) * this.DAYS_PER_YEAR) + (this.SEASON_WINTER * this.SEASON_LENGTH) + 91;
                if(time.currentDayOfYear > (this.SEASON_WINTER * this.SEASON_LENGTH) + 91) nextNewYearDay += this.DAYS_PER_YEAR;
                upcoming.push({ name: "New Year Celebration", icon: '<img src="img/Enchanted_Cake.webp" style="width:30px">', nextDay: nextNewYearDay });

                // Traveling Zoo
                const summerStart = (this.SEASON_SUMMER * this.SEASON_LENGTH) + 1;
                const winterStart = (this.SEASON_WINTER * this.SEASON_LENGTH) + 1;
                let nextZooDay;
                if(time.currentDayOfYear < summerStart) nextZooDay = ((time.currentYear -1) * this.DAYS_PER_YEAR) + summerStart;
                else if(time.currentDayOfYear < winterStart) nextZooDay = ((time.currentYear -1) * this.DAYS_PER_YEAR) + winterStart;
                else nextZooDay = (time.currentYear * this.DAYS_PER_YEAR) + summerStart;
                const legendaryNext = this.getTravelingZooLegendaryForDay(nextZooDay) || { name: 'Unknown', icon: 'üêò' };
                upcoming.push({ name: "Traveling Zoo", icon: legendaryNext.icon, legendaryName: legendaryNext.name, nextDay: nextZooDay });

                // Calculate msUntil for all events
                upcoming.forEach(event => {
                    const daysUntil = event.nextDay - time.skyblockDecimalDays - 1;
                    event.msUntil = daysUntil * this.MINUTES_PER_SKYBLOCK_DAY * 60 * 1000;
                });
                
                return upcoming.sort((a,b) => a.msUntil - b.msUntil);
            },

            getRealTimeForDay(totalDay) {
                const realSeconds = this.START_OF_TIMES + ((totalDay - 1) * this.MINUTES_PER_SKYBLOCK_DAY * 60);
                return new Date(realSeconds * 1000);
            },
        };

        /**
         * UI CONTROLLER
         */
        const UIController = {
            currentPage: 1,
            currentSkyblockDay: 0,
            engine: null,
            elements: {},
            modalCountdownInterval: null,

            init(engine) {
                this.engine = engine;
                this.cacheDOMElements();
                this.bindEventListeners();
                // Determine the current skyblock day and jump to its page immediately
                const time = this.engine.getCurrentTimeData();
                this.currentSkyblockDay = time.currentSkyblockDay;
                // Ensure at least page 1
                this.currentPage = Math.max(1, Math.ceil(this.currentSkyblockDay / this.engine.DAYS_PER_PAGE));
                // Pre-calc current and next page for snappy navigation
                this.engine.preCalculatePage(this.currentPage);
                this.engine.preCalculatePage(this.currentPage + 1);
                // Render the page so the current day is highlighted right away
                this.renderCurrentPage();
                this.startTimers();
            },

            cacheDOMElements() {
                this.elements = {
                    calendarGrid: document.getElementById('calendar-grid'),
                    calendarPageEl: document.getElementById('calendar-page'),
                    calendarYearEl: document.getElementById('calendar-year'),
                    nextPageBtn: document.getElementById('next-page-btn'),
                    prevPageBtn: document.getElementById('prev-page-btn'),
                    currentDateInfoEl: document.getElementById('current-date-info'),
                    upcomingEventsListEl: document.getElementById('upcoming-events-list'),
                    modal: document.getElementById('day-modal'),
                    modalCloseBtn: document.getElementById('modal-close-btn')
                };
            },

            bindEventListeners() {
                this.elements.nextPageBtn.addEventListener('click', () => this.goToNextPage());
                this.elements.prevPageBtn.addEventListener('click', () => this.goToPrevPage());
                this.elements.modal.addEventListener('click', (e) => { if (e.target === this.elements.modal) this.closeModal(); });
                this.elements.modalCloseBtn.addEventListener('click', () => this.closeModal());
            },

            goToNextPage() {
                this.currentPage++;
                this.renderCurrentPage();
                this.engine.preCalculatePage(this.currentPage + 1);
            },
            
            goToPrevPage() {
                if (this.currentPage > 1) {
                    this.currentPage--;
                    this.renderCurrentPage();
                }
            },

            startTimers() {
                const update = () => {
                    const timeData = this.engine.getCurrentTimeData();
                    const newSkyblockDay = timeData.currentSkyblockDay;
                    const dayChanged = this.currentSkyblockDay !== newSkyblockDay;
                    this.currentSkyblockDay = newSkyblockDay;
                    this.elements.currentDateInfoEl.textContent = `Today: Year ${timeData.currentYear}, ${this.engine.SEASON_NAMES[timeData.currentSeason]}, Day ${timeData.currentDayOfSeason}`;
                    
                    if (dayChanged) {
                        // If the day moved into a different page, jump to that page
                        const newPage = Math.max(1, Math.ceil(this.currentSkyblockDay / this.engine.DAYS_PER_PAGE));
                        if (newPage !== this.currentPage) {
                            this.currentPage = newPage;
                            // Pre-calc the next page for smooth navigation
                            this.engine.preCalculatePage(this.currentPage + 1);
                        }
                        this.renderCurrentPage();
                    }
                    
                    const upcomingEvents = this.engine.getUpcomingEventsData();
                    this.renderUpcomingEvents(upcomingEvents);
                };
                update();
                setInterval(update, 1000);
            },
            
            formatTime(ms) {
                if (ms < 0) return "0d 0h 0m 0s";
                let s = Math.floor(ms / 1000), m = Math.floor(s / 60);
                let h = Math.floor(m / 60), d = Math.floor(h / 24);
                return `${d}d ${h % 24}h ${m % 60}m ${s % 60}s`;
            },
            
            renderUpcomingEvents(events) {
                this.elements.upcomingEventsListEl.innerHTML = events.map(event => {
                    let subtext = 'Starts in...';
                    if (event.type === 'farming' && event.crops) {
                        subtext = event.crops.map(c => this.engine.CROP_ICONS[c] || '?').join(' ');
                    } else if (event.name === 'Traveling Zoo' && event.legendaryName) {
                        subtext = `Legendary pet: ${capitalize(event.legendaryName)} ${event.icon}`;
                    }
                    return `
                        <div class="event-timer-item">
                            <div class="event-timer-info">
                                <span class="event-icon">${event.icon}</span>
                                <div>
                                    <p class="event-name">${event.name}</p>
                                    <p class="event-subtext">${subtext}</p>
                                </div>
                            </div>
                            <div class="event-timer-countdown">${this.formatTime(event.msUntil)}</div>
                        </div>`;
                }).join('');
            },
 
             renderCurrentPage() {
                 const pageData = this.engine.getPageData(this.currentPage);
                 this.renderPage(pageData);
             },
 
             renderPage(pageData) {
                 this.elements.calendarGrid.innerHTML = '';
                 if (!pageData) return;
                 
                 this.elements.calendarPageEl.textContent = this.currentPage;
                 this.elements.calendarYearEl.textContent = pageData[0].year;
                 this.elements.prevPageBtn.disabled = this.currentPage <= 1;
 
                 pageData.forEach(dayInfo => {
                     const dayCell = document.createElement('div');
                     dayCell.className = 'day-cell';
                     if (dayInfo.totalDay === this.currentSkyblockDay) dayCell.classList.add('current-day');
                     
                     let eventContent = '';
                     if (dayInfo.events.length > 0) {
                         const icons = dayInfo.events.slice(0, 2).map(e => e.icon).join('');
                         const moreCount = dayInfo.events.length - 2;
                         eventContent = `<div class="event-icons-wrapper">${icons}${moreCount > 0 ? `<span class="multiple-events-indicator">+${moreCount}</span>` : ''}</div>`;
                     }
 
                     dayCell.innerHTML = `
                         <div class="day-cell-header">
                             <span class="day-season">${dayInfo.season.substring(0,3)} ${dayInfo.dayOfSeason}</span>
                             <span class="day-total">ID ${dayInfo.totalDay}</span>
                         </div>
                         <div class="day-cell-body">${eventContent}</div>`;
                     dayCell.addEventListener('click', () => this.showDayDetails(dayInfo));
                     this.elements.calendarGrid.appendChild(dayCell);
                 });
             },
 
             showDayDetails(dayInfo) {
                const realDate = this.engine.getRealTimeForDay(dayInfo.totalDay);
                document.getElementById('modal-ingame-date').textContent = `Year ${dayInfo.year}, ${dayInfo.season} ${dayInfo.dayOfSeason}`;
                document.getElementById('modal-real-date').textContent = `Date: ${realDate.toLocaleString()}`;
                // Setup countdown
                const countdownEl = document.getElementById('modal-countdown-to-day');
                if (this.modalCountdownInterval) clearInterval(this.modalCountdownInterval);
                const updateCountdown = () => {
                    const now = Date.now();
                    const ms = realDate.getTime() - now;
                    if (ms > 0) {
                        countdownEl.style.display = '';
                        countdownEl.textContent = `Countdown: ${this.formatTime(ms)}`;
                    } else {
                        countdownEl.style.display = 'none';
                    }
                };
                updateCountdown();
                this.modalCountdownInterval = setInterval(updateCountdown, 1000);

                const eventListEl = document.getElementById('modal-event-list');
                const eventsTitleEl = document.getElementById('modal-events-title');
                eventListEl.innerHTML = '';
                
                if (dayInfo.events.length > 0) {
                    eventsTitleEl.style.display = 'block';
                    dayInfo.events.forEach(event => {
                        const li = document.createElement('li');
                        li.className = 'modal-event-item';
                        let subtext = '';
                        if (event.type === 'farming') {
                            subtext = ` <span style="color: var(--text-secondary); font-size: 0.9rem;">(${event.crops.join(', ')})</span>`;
                        } else if (event.name === 'Traveling Zoo' && event.legendaryName) {
                            subtext = ` <span style="color: var(--text-secondary); font-size: 0.9rem;">(Legendary: ${capitalize(event.legendaryName)} ${event.icon})</span>`;
                        }
                        li.innerHTML = `<span class="event-icon">${event.icon}</span> <span>${event.name}${subtext}</span>`;
                        eventListEl.appendChild(li);
                    });
                } else {
                    eventsTitleEl.style.display = 'none';
                    eventListEl.innerHTML = '<li>No events on this day.</li>';
                }
                this.elements.modal.classList.add('visible');
             },
 
             closeModal() {
                 this.elements.modal.classList.remove('visible');
                 // Stop countdown timer
                 if (this.modalCountdownInterval) {
                     clearInterval(this.modalCountdownInterval);
                     this.modalCountdownInterval = null;
                 }
             }
         };
 
         document.addEventListener('DOMContentLoaded', () => {
             UIController.init(CalendarEngine);
         });

        function capitalize(val) {
            return String(val).charAt(0).toUpperCase() + String(val).slice(1);
        }
     </script>
 </body>
 </html>