<!--todo: 
underneath calendar add the same timers and next 10 calculations as we have already, all in one page. 
This is gonna be hugeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee
anyways i have the new covid variant so im going to sleep bye
-->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CraftersMC Skyblock Calendar</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="css/essential.css" />
    <!--<link rel="stylesheet" href="css/skycalendar.css" />-->
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet" />
    <script src="js/script.js" defer></script>
    <style>
        :root {
            --bg-primary: rgba(0, 0, 0, 0.5);
            --bg-secondary: rgba(0, 0, 0, 0);
            --bg-tertiary: rgba(100, 100, 100, 0.5);
            --bg-interactive: #4b5563;
            --border-color: #4b5563;
            --text-primary: #f3f4f6;
            --text-secondary: #9ca3af;
            --accent-color: #007bff;
            --accent-hover: #005bef;
            --highlight-color: #f59e0b;
        }
        
        body {
            font-family: 'Inter', sans-serif;
            background-image: url('Backgrounds/IMG_4500Blurred.webp');
            background-size: cover;
            background-attachment: fixed;
            background-position: center;
            color: var(--text-primary);
            margin: 0;
            padding: 1rem;
        }

        body::after {
            content: "";
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            pointer-events: none;
            z-index: -1;
        }

        .container {
            display: flex;
            flex-direction: column;
            max-width: 1280px;
            margin: 0 auto;
            align-items: center;
        }

        /*general elements*/
        header {
            text-align: center;
            margin-bottom: 2rem;
            background-color: var(--bg-secondary);
            border-radius: 16px;
            
            padding: 5px;
        }
        header h1 {
            font-size: 2.25rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
        }
        header p {
            font-size: 1.125rem;
            color: var(--text-secondary);
        }

        .card {
            background-color: var(--bg-secondary);
            border-radius: 1rem;
            box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1), 0 4px 6px -2px rgba(0,0,0,0.05);
            border: 2px solid rgba(255, 255, 255, 0.2);
            padding: 1.5rem;
            margin-bottom: 2rem;
            width: 95%;
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }
        
        .card-header h2 {
            font-size: 1.5rem;
            font-weight: 600;
        }
        
        .pagination {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        
        .pagination span {
            font-size: 1.125rem;
            font-weight: 500;
            text-align: center;
            width: 5rem;
        }
        
        
        button:disabled {
            background-color: var(--bg-tertiary);
            opacity: 0.5;
            cursor: not-allowed;
        }
        

        #prev-page-btn:not(:disabled):hover {
            background-color: var(--bg-interactive);
        }
        
        /*calendar stuff*/
        #calendar-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 0.75rem;
        }
        
        .day-cell {
            padding: 0.75rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1), 0 2px 4px -1px rgba(0,0,0,0.06);
            display: flex;
            flex-direction: column;
            height: 8rem;
            transition: transform 0.2s, box-shadow 0.2s;
            background-color: var(--bg-tertiary);
            cursor: pointer;
        }

        .day-cell img {
            width: 36px;
            height: auto;
        }

        .day-cell:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 15px -3px rgba(0,0,0,0.2), 0 4px 6px -2px rgba(0,0,0,0.1);
        }

        .day-cell.current-day {
            outline: 3px solid var(--highlight-color);
        }
        
        .day-cell-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.75rem;
            margin-bottom: 0.25rem;
        }
        
        .day-cell-header .day-season {
            font-weight: 700;
            opacity: 0.8;
        }
        
        .day-cell-header .day-total {
            opacity: 0.6;
        }
        
        .day-cell-body {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            overflow: hidden;
        }
        
        .event-icon {
            font-size: 1.5rem; 
        }

        .event-icons-wrapper {
            display: flex;
            gap: 0.5rem;
            font-size: 1.25rem;
            align-items: center;
        }
        .event-name {
             margin-top: auto; 
             font-size: 0.75rem; 
             font-weight: 600;
        }
        .multiple-events-indicator { 
            font-size: 0.8rem; 
            font-weight: bold; 
            color: var(--text-secondary); }

        /*events section*/
        #upcoming-events-list { 
            display: flex; flex-direction: column; gap: 1rem; 
        }
        .event-timer-item { 
            display: flex; 
            align-items: center; 
            justify-content: space-between; 
            background-color: rgba(55, 65, 81, 0.5); 
            padding: 0.75rem; 
            border-radius: 0.5rem; 
            min-height: 100px;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .event-timer-item:hover {
            transform: scale(1.05);
        }

        .event-timer-item img {
            width: 36px;
            height: auto;
        }

        .event-timer-info {
             display: flex; 
             align-items: center; 
             gap: 0.4rem; 
             margin: 4px;

        }
        .event-timer-info .event-name {
             font-weight: 600; 
        }

        .event-timer-info .expand-text {
            
            font-size: 0.75rem;
            transition: background-color 0.2s;
        }

        .event-timer-info .event-subtext {
             font-size: 0.75rem; 
             color: var(--text-secondary);
             display: flex;
             align-items: center; 
             margin: 8px 0;
        }
        .event-timer-countdown {
             font-family: monospace; 
             font-size: 1.125rem; 
             color: var(--highlight-color); 
        }
        

        /*modal section*/
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(17, 24, 39, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
        }

        .modal-overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background-color: var(--bg-secondary);
            backdrop-filter: blur(10px);
            padding: 2rem;
            border-radius: 1rem;
            width: 90%;
            max-width: 500px;
            position: relative;
            transform: scale(0.95);
            transition: transform 0.3s;
        }

        .modal-content img {
            width: 48px;
            height: auto;
        }

        .modal-overlay.visible .modal-content {
            transform: scale(1);
        }

        .modal-close-btn {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1.5rem;
            cursor: pointer;
        }

        .modal-header h3 { 
            font-size: 1.5rem; 
            font-weight: 600; 
            margin: 0; 
        }
        .modal-header p { 
            color: var(--text-secondary); 
            
        }
        .modal-body { 
            margin-top: 1.5rem; 
        }
        .modal-body h4 { 
            font-weight: 600; 
            border-bottom: 1px solid var(--border-color); 
            padding-bottom: 0.5rem; 
            margin: 0 0 1rem 0; 
        }
        .modal-event-list { 
            list-style: none; 
            padding: 0; 
            margin: 0; 
            display: flex; 
            flex-direction: column; 
            gap: 0.75rem; 
        }
        .modal-event-item { 
            display: flex; 
            align-items: center; 
            gap: 1rem; 
        }
        .modal-event-item .event-icon { 
            font-size: 1.75rem; 
        }

        .modal-event-item span {
            display: flex;
            align-items: center;
            gap: 4px
        }

        /* accordion + table */
        .accordion { 
            margin-top: 1rem; 
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        .accordion-item {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.04);
        }
        .accordion-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.75rem;
            padding: 0.6rem 0.8rem;
        }
        .accordion-header .left {
            display: flex;
            gap: 0.6rem;
            align-items: center;
        }
        .accordion-header h3 {
            margin: 0;
            font-size: 1rem;
            font-weight: 600;
        }
        .accordion-body {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.28s ease;
        }
        .accordion-body.expanded {
            padding: 0.75rem;
            max-height: 1000px;
        }
        .occurrences-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9rem;
        }
        .occurrences-table th, .occurrences-table td {
            text-align: left;
            padding: 0.45rem 0.5rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.03);
        }
        .occurrences-table th {
            font-weight: 600;
            color: var(--text-secondary);
            font-size: 0.8rem;
        }
        .occ-extra { color: var(--text-secondary); font-size: 0.85rem; display:flex; gap:6px; align-items:center; }

        /* farming filter checkboxes (new) */
        .farming-filters {
            display: flex;
            flex-wrap: wrap;
            gap: 0.4rem;
            margin-bottom: 0.5rem;
            align-items: center;
        }
        .farming-filter {
            display: inline-flex;
            align-items: center;
            gap: 0.35rem;
            padding: 0.25rem 0.45rem;
            background: rgba(255,255,255,0.02);
            border-radius: 6px;
            font-size: 0.85rem;
            cursor: pointer;
        }
        .farming-filter input[type="checkbox"] { transform: scale(1.05); }
        .farming-filter .crop-icon { margin-right: 0.25rem; }

        /* small screen adjustments */
        @media (max-width:640px) {
            .occurrences-table th:nth-child(3), .occurrences-table td:nth-child(3) { display:none; } /* hide in-game date column if needed */
        }
    </style>
</head>
<body>
    
  <div class="top"></div>
  <div class="sidebar" id="sidebar"></div>
  <div id="sidebar-overlay" onclick="toggleSidebar()"></div>
  <div class="gap"></div>
  <br>


    <div class="container">
        <header>
            <h1>Skyblock Calendar</h1>
            <p id="current-date-info">Loading current date...</p>
        </header>

        <div class="card">
            <div class="card-header">
                <h2>Calendar - Year <span id="calendar-year">1</span></h2>
                <div class="pagination">
                     <button id="prev-page-btn">&lt; Prev</button>
                    <span>Page <span id="calendar-page">1</span></span>
                    <button id="next-page-btn">Next &gt;</button>
                </div>
            </div>
            <div id="calendar-grid"></div>
        </div>

        <div class="card">
            <h2 style="border-bottom: 1px solid var(--border-color); padding-bottom: 0.75rem; margin-bottom: 1rem;">Upcoming Events</h2>
            <div id="upcoming-events-list"></div>

            <!-- accordion will be inserted directly under the clicked event item -->
         </div>
    </div>

    <div id="day-modal" class="modal-overlay">
        <div class="modal-content">
            <button id="modal-close-btn" class="modal-close-btn">&times;</button>
            <div class="modal-header">
                <h3 id="modal-ingame-date"></h3>
                <p id="modal-real-date"></p>
                <p id="modal-countdown-to-day" style="color:var(--highlight-color);font-family:monospace;margin-top:0.5em;"></p>
            </div>
            <div class="modal-body">
                <h4 id="modal-events-title">Events</h4>
                <ul id="modal-event-list"></ul>
            </div>
        </div>
    </div>
<div id="footer"></div>
    <script>
        /**
         * CALENDAR ENGINE
         * This object contains all pure calculation logic, free of any DOM manipulation.
         * It can be moved to a Web Worker file in the future.
         */
        
        const CalendarEngine = {
            
            // basic variables and some offsets
            START_OF_TIMES: 1648800000, //secs
            TIME_MULTIPLIER: 72,
            SEASON_LENGTH: 93, // in days obv
            YEAR_LENGTH: 4,
            DAYS_PER_YEAR: 372,
            DAYS_PER_PAGE: 31, 
            MINUTES_PER_SKYBLOCK_DAY: 20,
            SEASON_SPRING: 0, SEASON_SUMMER: 1, SEASON_AUTUMN: 2, SEASON_WINTER: 3,
            
            LEGENDARY_PATTERN: ['elephant','giraffe','tiger','lion','monkey'],
            LEGENDARY_ICONS: { 'elephant':'<img src="img/pets/Elephant_Pet.webp" style="height:40px;width:auto;">',

            'giraffe':'<img src="img/pets/Giraffe_Pet.webp" style="height:40px;width:auto;">',

            'tiger':'<img src="img/pets/300px-Tiger_pet.webp" style="height:40px;width:auto;">',

            'lion':'<img src="img/pets/300px-Lion_pet.webp" style="height:40px;width:auto;">',

            'monkey':'<img src="img/pets/Monkey_pet.webp" style="height:40px;width:auto;margin:4px;">'},
            TRAVELING_ZOO_LEGENDARY_OFFSET: 2,
            pagesDataCache: new Map(),
            SEASON_NAMES: ['Spring', 'Summer', 'Autumn', 'Winter'],
            CropType: ['WHEAT', 'SUGAR_CANE', 'CARROT', 'POTATO', 'MELON', 'PUMPKIN', 'COCOA_BEANS', 'CACTUS', 'MUSHROOM', 'BEETROOT'],
            //const crops = ["Wheat", "Sugar Cane", "Carrot", "Potato", "Melon", "Pumpkin", "Cocoa Beans", "Cactus", "Mushroom", "Beetroot"];
            CROP_ICONS: { 
                'WHEAT': '<img src="img/Wheat.webp" style="height:20px;width:auto;">',
                'SUGAR_CANE': '<img src="img/Sugar_Cane.webp" style="height:20px;width:auto;">',
                'CARROT': '<img src="img/Carrot.webp" style="height:20px;width:auto;">',
                'POTATO': '<img src="img/Potato.webp" style="height:20px;width:auto;">', 
                'MELON': '<img src="img/Melon.webp" style="height:20px;width:auto;">', 
                'PUMPKIN': '<img src="img/Pumpkin.webp" style="height:20px;width:auto;">', 
                'COCOA_BEANS': '<img src="img/Cocoa_Beans.webp" style="height:20px;width:auto;">', 
                'CACTUS': '<img src="img/Cactus.webp" style="height:20px;width:auto;">', 
                'MUSHROOM': '<img src="img/Mushroom.gif" style="height:20px;width:auto;">', 
                'BEETROOT': '<img src="img/Beetroot.webp" style="height:20px;width:auto;">' 
            },
            // farming contest seed algorithm from craftersmc official calendarjs
            Random: (function() {
                const MUL = 0x5DEECE66Dn;
                const ADD = 0xBn;
                const MASK48 = (1n << 48n) - 1n;
    
                return class JavaRandom {
                    constructor(seedVal) {
                        this.seed = 0n;
                        this.setSeed(Number(seedVal) || 0);
                    }
                    setSeed(seedVal) {
                        const s = BigInt(seedVal);
                        this.seed = (s ^ MUL) & MASK48;
                    }
                    next(bits) {
                        this.seed = (this.seed * MUL + ADD) & MASK48;
                        return Number(this.seed >> (48n - BigInt(bits)));
                    }
                    nextInt(bound) {
                        if (bound === undefined) return this.next(32) | 0;
                        if (!Number.isInteger(bound) || bound <= 0) throw new RangeError('bound must be positive integer');
                        if ((bound & (bound - 1)) === 0) {
                            return Math.floor(bound * (this.next(31) / 2147483648));
                        }
                        let bits, val;
                        do {
                            bits = this.next(31);
                            val = bits % bound;
                        } while (bits - val + (bound - 1) < 0);
                        return val;
                    }
                };
            })(),

            // helper to compute which legendary pet a travelling zoo has on a given totalDay
            getTravelingZooLegendaryForDay(totalDay) {
                const daysSinceEpoch = totalDay - 1;
                const seasonsSinceEpoch = Math.floor(daysSinceEpoch / this.SEASON_LENGTH);
                const year = Math.floor(seasonsSinceEpoch / this.YEAR_LENGTH) + 1;
                const season = seasonsSinceEpoch % this.YEAR_LENGTH; // 0..3
                // only valid for summer/winter traveling zoo
                if (season !== this.SEASON_SUMMER && season !== this.SEASON_WINTER) return null;

                // occurrence index (zero-based): per year there are 2 zoos: summer then winter
                const occurrenceIndex = (year - 1) * 2 + (season === this.SEASON_SUMMER ? 0 : 1);
                const idx = (occurrenceIndex + this.TRAVELING_ZOO_LEGENDARY_OFFSET) % this.LEGENDARY_PATTERN.length;
                const name = this.LEGENDARY_PATTERN[idx];
                return { name, icon: this.LEGENDARY_ICONS[name] || '‚ùì' };
            },

            // --- Methods ---
            getPageData(pageNumber) {
                if (!this.pagesDataCache.has(pageNumber)) this.calculatePage(pageNumber);
                return this.pagesDataCache.get(pageNumber);
            },

            preCalculatePage(pageNumber) {
                if (!this.pagesDataCache.has(pageNumber)) this.calculatePage(pageNumber);
            },

            calculatePage(pageNumber) {
                const pageDays = [];
                const startDay = (pageNumber - 1) * this.DAYS_PER_PAGE + 1;
                const endDay = startDay + this.DAYS_PER_PAGE - 1;
                for (let day = startDay; day <= endDay; day++) pageDays.push(this.getDayInfo(day));
                this.pagesDataCache.set(pageNumber, pageDays);
            },
            
            getDayInfo(totalDay) {
                const daysSinceEpoch = totalDay - 1;
                const seasonsSinceEpoch = Math.floor(daysSinceEpoch / this.SEASON_LENGTH);
                const yearsSinceEpoch = Math.floor(seasonsSinceEpoch / this.YEAR_LENGTH);
 
                const year = yearsSinceEpoch + 1;
                const season = seasonsSinceEpoch % this.YEAR_LENGTH;
                const dayOfSeason = daysSinceEpoch % this.SEASON_LENGTH + 1;
                
                const events = [];
                if (daysSinceEpoch % 3 === 0) {
                    events.push({ name: 'Farming Contest', icon: '<img src="assets/farming/Farm-o-Matic.webp">', type: 'farming', crops: this.getFarmingCrops(Math.floor(daysSinceEpoch / 3)) });
                }
                if (season === this.SEASON_SPRING && (year - 1) % 4 === 0) {
                    events.push({ name: "Season of the Pig", icon: '<img src="img/100px-Shiny_Orb.webp">' });
                }
                if ((season === this.SEASON_SUMMER && dayOfSeason <= 3) || (season === this.SEASON_WINTER && dayOfSeason <= 3)) {
                    const legendary = this.getTravelingZooLegendaryForDay(totalDay) || { name: 'Error', icon: '‚ùå' };
                    events.push({ name: "Traveling Zoo", icon: legendary.icon, legendaryName: legendary.name });
                }
                 if (season === this.SEASON_WINTER && dayOfSeason >= 91) {
                     events.push({ name: "New Year Celebration", icon: '<img src="img/Enchanted_Cake.webp">' });
                 }
 
                 return { totalDay, year, season: this.SEASON_NAMES[season], dayOfSeason, events };
            },

            getFarmingCrops(eventId) {
                const GOLDEN = 0x9E3779B97F4A7C15n;
                const seed64 = (BigInt(eventId) ^ GOLDEN) & ((1n << 48n) - 1n);
                const seed48 = Number(seed64);
                const rng = new this.Random(seed48);
                const arr = this.CropType.slice();
                for (let i = arr.length - 1; i > 0; i--) {
                    const j = rng.nextInt(i + 1);
                    const tmp = arr[i];
                    arr[i] = arr[j];
                    arr[j] = tmp;
                }
                return arr.slice(0, 3);
            },
            
            getCurrentTimeData() {
                const realSecondsSinceEpoch = (Date.now() / 1000) - this.START_OF_TIMES;
                const skyblockSeconds = realSecondsSinceEpoch * this.TIME_MULTIPLIER;
                const skyblockDecimalDays = skyblockSeconds / 86400;
                
                const daysSinceEpoch = Math.floor(skyblockDecimalDays);
                const seasonsSinceEpoch = Math.floor(daysSinceEpoch / this.SEASON_LENGTH);
                const currentYear = Math.floor(seasonsSinceEpoch / this.YEAR_LENGTH) + 1;
                const currentSeason = seasonsSinceEpoch % this.YEAR_LENGTH;
                const currentDayOfSeason = daysSinceEpoch % this.SEASON_LENGTH + 1;

                return {
                    currentYear, currentSeason, currentDayOfSeason, skyblockDecimalDays,
                    currentSkyblockDay: daysSinceEpoch + 1,
                    currentDayOfYear: (currentSeason * this.SEASON_LENGTH) + currentDayOfSeason
                };
            },

            getUpcomingEventsData() {
                const time = this.getCurrentTimeData();
                const upcoming = [];

                // contest
                const nextContestDay = Math.floor(time.currentSkyblockDay / 3) * 3 + 1;
                upcoming.push({ name: "Farming Contest", icon: '<img src="assets/farming/Farm-o-Matic.webp">', type: 'farming', nextDay: nextContestDay > time.currentSkyblockDay ? nextContestDay : nextContestDay + 3, crops: this.getFarmingCrops(Math.floor(nextContestDay/3))});

                // SHINY PIGS MY GOAT
                let nextPigYear = Math.ceil(time.currentYear / 4) * 4 + 1; //+1 for accuracy
                if(time.currentYear > nextPigYear || (time.currentYear === nextPigYear && time.currentSeason > this.SEASON_SPRING)) nextPigYear += 4;
                upcoming.push({ name: "Season of the Pig", icon: '<img src="img/100px-Shiny_Orb.webp">', nextDay: ((nextPigYear - 1) * this.DAYS_PER_YEAR) + 1});

                // cake
                let nextNewYearDay = ((time.currentYear -1) * this.DAYS_PER_YEAR) + (this.SEASON_WINTER * this.SEASON_LENGTH) + 91;
                if(time.currentDayOfYear > (this.SEASON_WINTER * this.SEASON_LENGTH) + 91) nextNewYearDay += this.DAYS_PER_YEAR;
                upcoming.push({ name: "New Year Celebration", icon: '<img src="img/Enchanted_Cake.webp">', nextDay: nextNewYearDay });

                // zoo
                const summerStart = (this.SEASON_SUMMER * this.SEASON_LENGTH) + 1;
                const winterStart = (this.SEASON_WINTER * this.SEASON_LENGTH) + 1;
                let nextZooDay;
                if(time.currentDayOfYear < summerStart) nextZooDay = ((time.currentYear -1) * this.DAYS_PER_YEAR) + summerStart;
                else if(time.currentDayOfYear < winterStart) nextZooDay = ((time.currentYear -1) * this.DAYS_PER_YEAR) + winterStart;
                else nextZooDay = (time.currentYear * this.DAYS_PER_YEAR) + summerStart;
                const legendaryNext = this.getTravelingZooLegendaryForDay(nextZooDay) || { name: 'Unknown', icon: 'üêò' };
                upcoming.push({ name: "Traveling Zoo", icon: legendaryNext.icon, legendaryName: legendaryNext.name, nextDay: nextZooDay });

                // calculate msUntil for all events
                upcoming.forEach(event => {
                    const daysUntil = event.nextDay - time.skyblockDecimalDays - 1;
                    event.msUntil = daysUntil * this.MINUTES_PER_SKYBLOCK_DAY * 60 * 1000;
                });
                
                return upcoming.sort((a,b) => a.msUntil - b.msUntil);
            },

            // accordion next 10
            getNextOccurrences(eventName, startSkyblockDay, count = 10) {
                const results = [];
                const start = Math.max(1, Math.floor(startSkyblockDay));
                // helper to push enriched object
                const pushOcc = (totalDay, extra = {}) => {
                    const realDate = this.getRealTimeForDay(totalDay);
                    const msUntil = realDate.getTime() - Date.now();
                    results.push(Object.assign({ totalDay, realDate, msUntil }, extra));
                };

                if (eventName === 'Farming Contest') {
                    // occurs every 3 days: day ids 1,4,7,...
                    let first = Math.floor((start - 1) / 3) * 3 + 1;
                    if (first < start) first += 3;
                    for (let i = 0; results.length < count; i++) {
                        const day = first + i * 3;
                        const eventId = Math.floor((day - 1) / 3);
                        pushOcc(day, { crops: this.getFarmingCrops(eventId) });
                    }
                } else if (eventName === 'Traveling Zoo') {
                    const summerStart = (this.SEASON_SUMMER * this.SEASON_LENGTH) + 1;
                    const winterStart = (this.SEASON_WINTER * this.SEASON_LENGTH) + 1;
                    let year = Math.floor((start - 1) / this.DAYS_PER_YEAR) + 1;
                    while (results.length < count) {
                        const s = ((year - 1) * this.DAYS_PER_YEAR) + summerStart;
                        if (s >= start) {
                            const legendary = this.getTravelingZooLegendaryForDay(s) || { name: 'Unknown', icon: '‚ùì' };
                            pushOcc(s, { legendaryName: legendary.name, legendaryIcon: legendary.icon });
                        }
                        const w = ((year - 1) * this.DAYS_PER_YEAR) + winterStart;
                        if (results.length < count && w >= start) {
                            const legendary = this.getTravelingZooLegendaryForDay(w) || { name: 'Unknown', icon: '‚ùì' };
                            pushOcc(w, { legendaryName: legendary.name, legendaryIcon: legendary.icon });
                        }
                        year++;
                    }
                } else if (eventName === 'New Year Celebration') {
                    let year = Math.floor((start - 1) / this.DAYS_PER_YEAR) + 1;
                    while (results.length < count) {
                        const day = ((year - 1) * this.DAYS_PER_YEAR) + (this.SEASON_WINTER * this.SEASON_LENGTH) + 91;
                        if (day >= start) pushOcc(day);
                        year++;
                    }
                } else if (eventName === 'Season of the Pig') {
                    let year = Math.floor((start - 1) / this.DAYS_PER_YEAR) + 1;
                    while (results.length < count) {
                        const day = ((year - 1) * this.DAYS_PER_YEAR) + (this.SEASON_SPRING * this.SEASON_LENGTH) + 1;
                        if (((year - 1) % 4 === 0) && day >= start) pushOcc(day);
                        year++;
                    }
                } else {
                    // generic fallback: next consecutive days
                    for (let i = 0; results.length < count; i++) pushOcc(start + i);
                }

                return results.slice(0, count);
            },

            getRealTimeForDay(totalDay) {
                const realSeconds = this.START_OF_TIMES + ((totalDay - 1) * this.MINUTES_PER_SKYBLOCK_DAY * 60);
                return new Date(realSeconds * 1000);
            },
        };

        /**
         * UI CONTROLLER
         */
        const UIController = {
            currentPage: 1,
            currentSkyblockDay: 0,
            engine: null,
            elements: {},
            modalCountdownInterval: null,
            currentUpcomingEvents: [], // store last rendered upcoming events

            init(engine) {
                this.engine = engine;
                this.cacheDOMElements();
                this.bindEventListeners();
                // jump to todays page
                const time = this.engine.getCurrentTimeData();
                this.currentSkyblockDay = time.currentSkyblockDay;
                this.currentPage = Math.max(1, Math.ceil(this.currentSkyblockDay / this.engine.DAYS_PER_PAGE));
                // calc current and next page on start
                this.engine.preCalculatePage(this.currentPage);
                this.engine.preCalculatePage(this.currentPage + 1);
                // render all that
                this.renderCurrentPage();
                this.startTimers();
            },

            cacheDOMElements() {
                this.elements = {
                    calendarGrid: document.getElementById('calendar-grid'),
                    calendarPageEl: document.getElementById('calendar-page'),
                    calendarYearEl: document.getElementById('calendar-year'),
                    nextPageBtn: document.getElementById('next-page-btn'),
                    prevPageBtn: document.getElementById('prev-page-btn'),
                    currentDateInfoEl: document.getElementById('current-date-info'),
                    upcomingEventsListEl: document.getElementById('upcoming-events-list'),
                    modal: document.getElementById('day-modal'),
                    modalCloseBtn: document.getElementById('modal-close-btn')
                };
            },

            bindEventListeners() {
                this.elements.nextPageBtn.addEventListener('click', () => this.goToNextPage());
                this.elements.prevPageBtn.addEventListener('click', () => this.goToPrevPage());
                this.elements.modal.addEventListener('click', (e) => { if (e.target === this.elements.modal) this.closeModal(); });
                this.elements.modalCloseBtn.addEventListener('click', () => this.closeModal());

                // handle clicks on upcoming events via delegation
                this.elements.upcomingEventsListEl.addEventListener('click', (e) => {
                    const item = e.target.closest('.event-timer-item');
                    if (!item) return;
                    const idx = Number(item.dataset.eventIndex);
                    const ev = this.currentUpcomingEvents && this.currentUpcomingEvents[idx];

                    // toggle: if this item already has an inserted accordion directly after it, remove it;
                    // otherwise insert one for this event.
                    const next = item.nextElementSibling;
                    if (next && next.classList.contains('event-occurrences-wrapper')) {
                        next.remove();
                        return;
                    }
                    if (ev) this.showEventOccurrences(ev, item);
                });
            },

            goToNextPage() {
                this.currentPage++;
                this.renderCurrentPage();
                this.engine.preCalculatePage(this.currentPage + 1);
            },
            
            goToPrevPage() {
                if (this.currentPage > 1) {
                    this.currentPage--;
                    this.renderCurrentPage();
                }
            },

            startTimers() {
                // init timers
                let upcomingEvents = this.engine.getUpcomingEventsData().map(event => {
                    event.targetTime = Date.now() + event.msUntil;
                    return event;
                });
                this.currentUpcomingEvents = upcomingEvents;
                this.renderUpcomingEvents(upcomingEvents);

                // update countdowns
                setInterval(() => {
                    upcomingEvents.forEach((event, idx) => {
                        const countdownEl = document.querySelectorAll('.event-timer-countdown')[idx];
                        if (countdownEl) {
                            const msLeft = event.targetTime - Date.now();
                            countdownEl.textContent = this.formatTime(msLeft);
                        }
                    });
                }, 1000);

                // on day change update everything
                setInterval(() => {
                    const timeData = this.engine.getCurrentTimeData();
                    const newSkyblockDay = timeData.currentSkyblockDay;
                    const dayChanged = this.currentSkyblockDay !== newSkyblockDay;
                    this.currentSkyblockDay = newSkyblockDay;
                    this.elements.currentDateInfoEl.textContent = `Today: Year ${timeData.currentYear}, ${this.engine.SEASON_NAMES[timeData.currentSeason]}, Day ${timeData.currentDayOfSeason}`;
                    if (dayChanged) {
                        const newPage = Math.max(1, Math.ceil(this.currentSkyblockDay / this.engine.DAYS_PER_PAGE));
                        if (newPage !== this.currentPage) {
                            this.currentPage = newPage;
                            this.engine.preCalculatePage(this.currentPage + 1);
                        }
                        this.renderCurrentPage();
                        // refresh events with new day
                        upcomingEvents = this.engine.getUpcomingEventsData().map(event => {
                            event.targetTime = Date.now() + event.msUntil;
                            return event;
                        });
                        this.currentUpcomingEvents = upcomingEvents;
                        this.renderUpcomingEvents(upcomingEvents);
                    }
                }, 1000);
            },
            
            formatTime(ms) {
                if (ms < 0) return "0d 0h 0m 0s";
                let s = Math.floor(ms / 1000), m = Math.floor(s / 60);
                let h = Math.floor(m / 60), d = Math.floor(h / 24);
                return `${d}d ${h % 24}h ${m % 60}m ${s % 60}s`;
            },
            
            renderUpcomingEvents(events) {
                // keep controller copy
                this.currentUpcomingEvents = events;
                this.elements.upcomingEventsListEl.innerHTML = events.map((event, idx) => {
                    let subtext = 'Starts in...';
                    if (event.type === 'farming' && event.crops) {
                        subtext = event.crops.map(c => this.engine.CROP_ICONS[c] || '?').join(' ');
                    } else if (event.name === 'Traveling Zoo' && event.legendaryName) {
                        subtext = `Legendary pet: ${capitalize(event.legendaryName)}`;
                    }
                    return `
                        <div class="event-timer-item" data-event-index="${idx}">
                            <div class="event-timer-info">
                                <span class="event-icon">${event.icon}</span>
                                <div>
                                    <p class="event-name">${event.name}</p>
                                    <p class="event-subtext">${subtext}</p>
                                    <p class="expand-text">Click to see next 10 timings</p>
                                </div>
                            </div>
                            <div class="event-timer-countdown">${this.formatTime(event.msUntil)}</div>
                        </div>
                        `;
                }).join('');
            },
 
             renderCurrentPage() {
                 const pageData = this.engine.getPageData(this.currentPage);
                 this.renderPage(pageData);
             },
 
             renderPage(pageData) {
                 this.elements.calendarGrid.innerHTML = '';
                 if (!pageData) return;
                 
                 this.elements.calendarPageEl.textContent = this.currentPage;
                 this.elements.calendarYearEl.textContent = pageData[0].year;
                 this.elements.prevPageBtn.disabled = this.currentPage <= 1;
 
                 pageData.forEach(dayInfo => {
                     const dayCell = document.createElement('div');
                     dayCell.className = 'day-cell';
                     if (dayInfo.totalDay === this.currentSkyblockDay) dayCell.classList.add('current-day');
                     
                     let eventContent = '';
                     if (dayInfo.events.length > 0) {
                         const icons = dayInfo.events.slice(0, 2).map(e => e.icon).join('');
                         const moreCount = dayInfo.events.length - 2;
                         eventContent = `<div class="event-icons-wrapper">${icons}${moreCount > 0 ? `<span class="multiple-events-indicator">+${moreCount}</span>` : ''}</div>`;
                     }
 
                     dayCell.innerHTML = `
                         <div class="day-cell-header">
                             <span class="day-season">${dayInfo.season.substring(0,3)} ${dayInfo.dayOfSeason}</span>
                             <span class="day-total">ID ${dayInfo.totalDay}</span>
                         </div>
                         <div class="day-cell-body">${eventContent}</div>`;
                     dayCell.addEventListener('click', () => this.showDayDetails(dayInfo));
                     this.elements.calendarGrid.appendChild(dayCell);
                 });
             },
 
             showDayDetails(dayInfo) {
                const realDate = this.engine.getRealTimeForDay(dayInfo.totalDay);
                document.getElementById('modal-ingame-date').textContent = `Year ${dayInfo.year}, ${dayInfo.season} ${dayInfo.dayOfSeason}`;
                document.getElementById('modal-real-date').textContent = `Date: ${realDate.toLocaleString()}`;
                const countdownEl = document.getElementById('modal-countdown-to-day');
                if (this.modalCountdownInterval) clearInterval(this.modalCountdownInterval);

                const updateCountdown = () => {
                    const now = Date.now();
                    const ms = realDate.getTime() - now;
                    if (ms > 0) {
                        countdownEl.style.display = '';
                        countdownEl.textContent = `Countdown: ${this.formatTime(ms)}`;
                    } else {
                        countdownEl.style.display = 'none';
                    }
                };
                updateCountdown();
                this.modalCountdownInterval = setInterval(updateCountdown, 1000);

                const eventListEl = document.getElementById('modal-event-list');
                const eventsTitleEl = document.getElementById('modal-events-title');
                eventListEl.innerHTML = '';
                
                if (dayInfo.events.length > 0) {
                    eventsTitleEl.style.display = 'block';
                    dayInfo.events.forEach(event => {
                        const li = document.createElement('li');
                        li.className = 'modal-event-item';
                        let subtext = '';
                        if (event.type === 'farming') {
                            subtext = ` <span style="color: var(--text-secondary); font-size: 0.9rem;">(${event.crops.join(', ')})</span>`;
                        } else if (event.name === 'Traveling Zoo' && event.legendaryName) {
                            subtext = ` <span style="color: var(--text-secondary); font-size: 0.9rem;">(Legendary: ${capitalize(event.legendaryName)})</span>`;
                        }
                        li.innerHTML = `<span class="event-icon">${event.icon}</span> <span>${event.name}${subtext}</span>`;
                        eventListEl.appendChild(li);
                    });
                } else {
                    eventsTitleEl.style.display = 'none';
                    eventListEl.innerHTML = '<li>No events on this day.</li>';
                }
                this.elements.modal.classList.add('visible');
             },
 
             // REPLACE: showEventOccurrences now inserts an accordion directly under the clicked event item
             showEventOccurrences(event, itemEl) {
                // remove any existing inserted accordions
                document.querySelectorAll('.event-occurrences-wrapper').forEach(el => el.remove());

                const occ = this.engine.getNextOccurrences(event.name, this.currentSkyblockDay, 200); // request many then filter if needed

                // determine if any occurrence has extra info (crops or legendary)
                const hasExtra = occ.some(o => (o.crops && o.crops.length) || o.legendaryName);

                // wrapper uses existing accordion styles so it pushes following items down
                const wrapper = document.createElement('div');
                wrapper.className = 'event-occurrences-wrapper accordion';

                const accItem = document.createElement('div');
                accItem.className = 'accordion-item';
                accItem.setAttribute('data-event-name', event.name);

                const header = document.createElement('div');
                header.className = 'accordion-header';
                header.innerHTML = `
                    <div class="left">
                        <div>
                            <h3>${event.name}</h3>
                            <div style="font-size:0.85rem;color:var(--text-secondary)">${event.type === 'farming' && event.crops ? event.crops.map(c => this.engine.CROP_ICONS[c] || c).join(' ') : (event.legendaryName ? 'Legendary: ' + capitalize(event.legendaryName) : '')}</div>
                        </div>
                    </div>
                    <div style="font-size:0.85rem;color:var(--text-secondary)">Next 10 occurrences</div>
                `;

                const body = document.createElement('div');
                body.className = 'accordion-body';

                // For farming contests: render crop filters and support filtered next-10 matching contests
                if (event.name === 'Farming Contest') {
                    // create filter container
                    const filterContainer = document.createElement('div');
                    filterContainer.className = 'farming-filters';

                    // list of crops to allow filtering (use engine.CropType order)
                    this.engine.CropType.forEach(cropKey => {
                        const label = document.createElement('label');
                        label.className = 'farming-filter';
                        label.title = cropKey;
                        label.innerHTML = `<input type="checkbox" value="${cropKey}"><span class="crop-icon">${this.engine.CROP_ICONS[cropKey] || ''}</span><span class="crop-name">${cropKey.replace('_',' ')}</span>`;
                        filterContainer.appendChild(label);
                    });

                    body.appendChild(filterContainer);

                    // create table element below filters
                    const table = document.createElement('table');
                    table.className = 'occurrences-table';
                    body.appendChild(table);

                    // helper to render table rows given a list of occurrences
                    const renderTable = (list) => {
                        // header includes Extra column because farming contests always have crops
                        table.innerHTML = `
                            <thead>
                                <tr>
                                    <th>In-game date</th>
                                    <th>Real date (local)</th>
                                    <th>Time until</th>
                                    <th>Extra</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${list.slice(0,10).map(o => {
                                    const dayInfo = this.engine.getDayInfo(o.totalDay);
                                    const shortSeason = dayInfo.season.substring(0,3);
                                    const realStr = o.realDate.toLocaleString();
                                    const until = this.formatTime(o.msUntil);
                                    const cropsText = (o.crops || []).map(c => `${this.engine.CROP_ICONS[c] || ''}`);
                                    return `<tr>
                                        <td>Year ${dayInfo.year}, ${shortSeason} ${dayInfo.dayOfSeason}</td>
                                        <td>${realStr}</td>
                                        <td style="font-family:monospace;color:var(--highlight-color)">${until}</td>
                                        <td>${cropsText}</td>
                                    </tr>`;
                                }).join('')}
                            </tbody>
                        `;
                    };

                    // initial render: next 10 farming contests (filter none)
                    const farmingOcc = occ.filter(o => o.crops && o.crops.length).slice(0, 1000); // ensure plenty
                    renderTable(farmingOcc);

                    // when filters change, show next 10 contests that include checked crop(s)
                    filterContainer.addEventListener('change', () => {
                        const checked = Array.from(filterContainer.querySelectorAll('input:checked')).map(i => i.value);
                        if (checked.length === 0) {
                            // no filter: first 10 contests in chronological order
                            renderTable(farmingOcc);
                            return;
                        }
                        // find matching occurrences until we have 10 matches
                        const matches = [];
                        for (let i = 0; i < farmingOcc.length && matches.length < 10; i++) {
                            const o = farmingOcc[i];
                            if (o.crops && checked.some(c => o.crops.includes(c))) matches.push(o);
                        }
                        renderTable(matches);
                    });
                } else {
                    // Non-farming: build a single table with dynamic Extra column only if needed
                    const table = document.createElement('table');
                    table.className = 'occurrences-table';

                    const filtered = occ.slice(0, 10);
                    const hasExtraNonFarm = filtered.some(o => o.legendaryName);
                    const theadCols = [
                        '<th>In-game date</th>',
                        '<th>Real date (local)</th>',
                        '<th>Time until</th>'
                    ];
                    if (hasExtraNonFarm) theadCols.push('<th>Extra</th>');

                    table.innerHTML = `
                        <thead>
                            <tr>${theadCols.join('')}</tr>
                        </thead>
                        <tbody>
                            ${filtered.map(o => {
                                const dayInfo = this.engine.getDayInfo(o.totalDay);
                                const shortSeason = dayInfo.season.substring(0,3);
                                const realStr = o.realDate.toLocaleString();
                                const until = this.formatTime(o.msUntil);
                                let extra = '';
                                if (o.legendaryName) {
                                    const icon = o.legendaryIcon || (this.engine.LEGENDARY_ICONS && this.engine.LEGENDARY_ICONS[o.legendaryName]) || '';
                                    extra = `<span class="occ-extra">${icon} ${capitalize(o.legendaryName)}</span>`;
                                }
                                const baseCells = [
                                    `<td>Year ${dayInfo.year}, ${shortSeason} ${dayInfo.dayOfSeason}</td>`,
                                    `<td>${realStr}</td>`,
                                    `<td style="font-family:monospace;color:var(--highlight-color)">${until}</td>`
                                ];
                                if (hasExtraNonFarm) baseCells.push(`<td>${extra}</td>`);
                                return `<tr>${baseCells.join('')}</tr>`;
                            }).join('')}
                        </tbody>
                    `;
                    body.appendChild(table);
                }

                accItem.appendChild(header);
                accItem.appendChild(body);
                wrapper.appendChild(accItem);

                // insert wrapper directly after clicked item so it pushes others down
                itemEl.parentNode.insertBefore(wrapper, itemEl.nextSibling);

                // expand body after insertion
                requestAnimationFrame(() => body.classList.add('expanded'));

                // NOTE: header intentionally has no click handler so clicking accordion does nothing.
            },
 
             closeModal() {
                 this.elements.modal.classList.remove('visible');
                 if (this.modalCountdownInterval) {
                     clearInterval(this.modalCountdownInterval);
                     this.modalCountdownInterval = null;
                 }
             }
         };
 
         document.addEventListener('DOMContentLoaded', () => {
             UIController.init(CalendarEngine);
         });

        function capitalize(val) {
            return String(val).charAt(0).toUpperCase() + String(val).slice(1);
        }
     </script>
 </body>
 </html>