<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="icon" href="assets/cmc-icon.png" type="image/png">
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Item Details - CraftersMC Guides</title>
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <link rel="stylesheet" href="themes/minecraft/style.css">
  <script src="js/script.js"></script>
  <style>
    .top { display: flex; justify-content: space-between; align-items: center; padding: 0 20px; }
    #top-right-ui-container { position: fixed; top: 80px; right: 20px; z-index: 1001; display: flex; flex-direction: column; align-items: flex-end; gap: 10px; }
    .profile-card { display: flex; align-items: center; gap: 10px; background-color: rgba(0, 0, 0, 0.5); padding: 8px 12px; border-radius: 50px; color: white; text-decoration: none; transition: background-color 0.3s; }
    .profile-card:hover { background-color: rgba(0, 0, 0, 0.8); }
    .profile-card-avatar { width: 32px; height: 32px; border-radius: 50%; }
    .profile-card-name { font-weight: 500; font-size: 14px; }
    .dev-label { color: #ff4d4d; font-weight: bold; margin-left: 5px; }
    .login-btn { background-color: #5865F2; color: white; padding: 10px 15px; border-radius: 8px; text-decoration: none; font-weight: 500; display: flex; align-items: center; gap: 8px; }
    .dev-btn { background-color: #313131; color: #FFFFFF; padding: 10px 15px; border: 2px solid #555; border-radius: 4px; font-weight: normal; cursor: pointer; display: flex; align-items: center; gap: 8px; transition: background-color 0.2s; }
    .dev-btn:hover { background-color: #424242; }
    .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); display: none; align-items: center; justify-content: center; z-index: 9998; }
    .modal-content { background: #2a2a2a; padding: 25px; border-radius: 12px; width: 90%; max-width: 400px; border: 1px solid #444; }
    .modal-content h3 { margin-top: 0; }
    .modal-content input { width: 100%; padding: 10px; box-sizing: border-box; margin-bottom: 15px; background: #1a1a1a; border: 1px solid #555; color: white; border-radius: 5px;}
    .modal-actions { display: flex; justify-content: flex-end; gap: 10px; }
    .modal-btn { padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; }
    .modal-btn-save { background-color: #28a745; color: white; }
    .modal-btn-cancel { background-color: #6c757d; color: white; }
    .toggle-switch-container { display: flex; align-items: center; justify-content: space-between; margin-bottom: 20px; }
    .switch { position: relative; display: inline-block; width: 50px; height: 28px; }
    .switch input { opacity: 0; width: 0; height: 0; }
    .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 28px; }
    .slider:before { position: absolute; content: ""; height: 20px; width: 20px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
    input:checked + .slider { background-color: #28a745; }
    input:checked + .slider:before { transform: translateX(22px); }
    .toast-notification { position: fixed; bottom: -100px; left: 50%; transform: translateX(-50%); padding: 15px 25px; border-radius: 8px; color: white; font-weight: 500; transition: bottom 0.5s ease-in-out; z-index: 10001; }
    .toast-notification.show { bottom: 30px; }
    .toast-notification.success { background-color: #2d8831; }
    .toast-notification.error { background-color: #c62828; }
    .private-item-highlight { border: 2px dashed #ff9800; background-color: rgba(255, 152, 0, 0.1); padding: 10px; border-radius: 10px; margin-bottom: 15px; }
    @media (max-width: 768px) { #top-right-ui-container { top: 65px; right: 10px; gap: 8px; } .profile-card { padding: 4px 8px; } .profile-card-avatar { width: 28px; height: 28px; } .profile-card-name { font-size: 12px; } .dev-btn { padding: 6px 10px; font-size: 12px; } .dev-btn .material-icons { font-size: 16px; } }
  </style>
</head>
<body>
  <div id="loader"><div></div><div></div><div></div></div>
  <div class="market-background"></div>
  <div id="top-right-ui-container"><div id="profile-card-container"></div><div id="dev-actions-container"></div></div>
  <div class="top"></div>
  <div class="sidebar" id="sidebar"></div>
  <div id="sidebar-overlay" onclick="toggleSidebar()"></div>
  <span class="item-material-icons" id="scrollToTopBtn">north</span>
  <div class="item-filter-buttons" style="display:flex;gap:10px;justify-content:center;margin:5rem 0;">
    <button class="btn item-filter-btn" data-nature="reset">Reset Filter</button>
  </div>
  <div class="item-container" id="itemDetails"><p>Loading item details...</p></div>
  <div class="item-nav-buttons">
    <button id="prevItemBtn" class="btn" type="button">&larr; Previous</button>
    <button id="nextItemBtn" class="btn" type="button">Next &rarr;</button>
  </div>
  <div id="footer"></div>

  <div id="price-modal" class="modal-overlay">
    <div class="modal-content">
        <h3>Update Item Details</h3>
        <label for="marketPriceInput">Market Price:</label>
        <input type="number" id="marketPriceInput" placeholder="Enter new market price">
        <label for="npcPriceInput">NPC Trade Price:</label>
        <input type="number" id="npcPriceInput" placeholder="Leave blank if not applicable">
        <div class="toggle-switch-container">
            <span>Public Status:</span>
            <label class="switch"><input type="checkbox" id="publicStatusToggle"><span class="slider"></span></label>
        </div>
        <div class="modal-actions">
            <button id="cancel-price-update" class="modal-btn modal-btn-cancel">Cancel</button>
            <button id="save-price-update" class="modal-btn modal-btn-save">Save Changes</button>
        </div>
    </div>
  </div>

  <script>
    const GITHUB_REPO = "CraftersMC-Guides-Project/guides-code";
    const MARKET_FILE_PATH = "market/market.txt";
    const PRICES_FILE_PATH = "market/mprices.txt";
    const GITHUB_BRANCH = "main";
    let isDevUser = false;
    let allItems = [];

    function getCookie(name) { const value = `; ${document.cookie}`; const parts = value.split(`; ${name}=`); if (parts.length === 2) return decodeURIComponent(parts.pop().split(';').shift()); return ''; }

    async function loadProfileCard() {
        const storedUser = getCookie("discordUser");
        const profileContainer = document.getElementById("profile-card-container");
        let devIds = [];
        try { const response = await fetch('/devs.txt'); if (response.ok) { const text = await response.text(); devIds = text.split('\n').map(id => id.trim()).filter(id => id); } } catch (error) {}
        if (storedUser) { const user = JSON.parse(storedUser); const displayName = user.global_name || user.username; isDevUser = devIds.includes(user.id);
            profileContainer.innerHTML = `<a href="/profile" class="profile-card"><img src="https://cdn.discordapp.com/avatars/${user.id}/${user.avatar}.png" class="profile-card-avatar"><span class="profile-card-name">${displayName}${isDevUser ? '<span class="dev-label">[DEV]</span>' : ''}</span></a>`; } else { profileContainer.innerHTML = ''; }
    }

    async function fetchAllItems() { try { const res = await fetch("market/market.txt"); allItems = await res.json(); } catch (e) { console.error("Could not fetch market.txt", e); } }

    async function loadItemDetails() {
      const urlParams = new URLSearchParams(window.location.search);
      const itemId = urlParams.get('item');
      if (itemId) {
        try {
          const [marketRes, pricesRes] = await Promise.all([fetch('market/market.txt'), fetch('market/mprices.txt')]);
          const marketData = await marketRes.text();
          const pricesData = await pricesRes.text();
          const items = JSON.parse(marketData);
          const item = items.find(item => item.id === itemId);
          if (item) {
            const isPublic = item.hasOwnProperty("public") ? item.public : true;
            if (!isPublic && !isDevUser) { document.getElementById('itemDetails').innerHTML = `<h2 style="color:red;">Error: This item doesn't exist.</h2>`; document.getElementById("dev-actions-container").innerHTML = ""; return; }
            if (isDevUser) { document.getElementById("dev-actions-container").innerHTML = `<button class="dev-btn" onclick="openUpdateModal()"><span class="material-icons">edit</span>Edit Details</button>`; }
            const pricesMap = new Map(); const npcPricesMap = new Map();
            pricesData.split('\n').forEach(line => { const [id, arrayStr] = line.split(':').map(part => part.trim()); if (id && arrayStr) { try { const parsedArray = JSON.parse(arrayStr); if (Array.isArray(parsedArray) && parsedArray.length >= 2) { pricesMap.set(id, parsedArray[1]); if (parsedArray.length >= 3) { npcPricesMap.set(id, parsedArray[2]); } } } catch (e) {} } });
            const marketPrice = pricesMap.get(item.id) ?? item.price ?? "N/A";
            const npcPrice = npcPricesMap.get(item.id);
            let privateHighlight = (isDevUser && !isPublic) ? `<div class='private-item-highlight'>PRIVATE ITEM (Visible only to Devs)</div>` : '';
            document.getElementById('itemDetails').innerHTML = `${privateHighlight}<h1>${item.name}</h1>${item.picture ? `<img src="${item.picture}" alt="${item.name}">` : ''}${item.rarity ? `<div class="item-rarity-display"><img class="item-rarity" src="img/rarity/${item.rarity}.webp"></div>` : ''}<p><strong class="item-strong">ID:</strong> ${item.id}</p><div class="item-price-container"><p class="item-price"><strong>Market Price:</strong> ${formatPrice(marketPrice)}</p><hr width="150px">${npcPrice !== null && npcPrice !== undefined ? `<p class="item-price"><strong>NPC Trade Price:</strong> ${formatPrice(npcPrice)}</p>` : ''}</div>`;
          } else { document.getElementById('itemDetails').innerHTML = `<h2 style="color:red;">Error: This item doesn't exist.</h2>`; }
        } catch (error) { console.error('Error loading item details:', error); document.getElementById('itemDetails').innerHTML = `<h2 style="color:red;">Error: Could not load item details.</h2>`; }
      }
    }

    async function openUpdateModal() {
        const urlParams = new URLSearchParams(window.location.search);
        const itemId = urlParams.get('item');
        try {
            const [pricesRes, marketRes] = await Promise.all([
                fetch('market/mprices.txt', { cache: 'no-cache' }),
                fetch('market/market.txt', { cache: 'no-cache' })
            ]);
            const pricesData = await pricesRes.text();
            const marketData = await marketRes.json();
            const item = marketData.find(i => i.id === itemId);
            if(item) {
                document.getElementById('publicStatusToggle').checked = item.public;
            }
            const lines = pricesData.split('\n');
            const line = lines.find(l => l.startsWith(itemId + ':'));
            if (line) {
                const arrayStr = line.split(':')[1].trim();
                const parsedArray = JSON.parse(arrayStr);
                document.getElementById('marketPriceInput').value = parsedArray[1] || '';
                document.getElementById('npcPriceInput').value = parsedArray[2] || '';
            }
        } catch (e) {
            showToast('Could not load current item data.', 'error');
        }
        document.getElementById('price-modal').style.display = 'flex';
    }

    document.getElementById('cancel-price-update').addEventListener('click', () => {
        document.getElementById('price-modal').style.display = 'none';
    });
    
    document.getElementById('save-price-update').addEventListener('click', async () => {
        const token = getCookie('githubToken');
        if (!token) {
            showToast('GitHub token not found. Please add it in your profile.', 'error');
            return;
        }
        const storedUser = getCookie("discordUser");
        if (!storedUser) {
            showToast('Could not identify user. Please log in again.', 'error');
            return;
        }
        const user = JSON.parse(storedUser);
        const userName = user.global_name || user.username;
        showToast('Saving changes to GitHub...', 'info');
        await saveAllChanges(token, userName);
    });

    // --- FIX: New single-commit save logic ---
    async function saveAllChanges(token, userName) {
        const urlParams = new URLSearchParams(window.location.search);
        const itemId = urlParams.get('item');

        try {
            // 1. Get the current branch's latest commit and tree
            const refRes = await fetch(`https://api.github.com/repos/${GITHUB_REPO}/git/refs/heads/${GITHUB_BRANCH}`, { headers: { Authorization: `token ${token}` } });
            if (!refRes.ok) throw new Error("Could not get branch reference.");
            const refData = await refRes.json();
            const latestCommitSha = refData.object.sha;

            const commitRes = await fetch(`https://api.github.com/repos/${GITHUB_REPO}/git/commits/${latestCommitSha}`, { headers: { Authorization: `token ${token}` } });
            if (!commitRes.ok) throw new Error("Could not get latest commit.");
            const commitData = await commitRes.json();
            const baseTreeSha = commitData.tree.sha;

            // 2. Get current file contents
            const [marketFileRes, pricesFileRes] = await Promise.all([
                fetch(`https://api.github.com/repos/${GITHUB_REPO}/contents/${MARKET_FILE_PATH}?ref=${GITHUB_BRANCH}`, { headers: { Authorization: `token ${token}` } }),
                fetch(`https://api.github.com/repos/${GITHUB_REPO}/contents/${PRICES_FILE_PATH}?ref=${GITHUB_BRANCH}`, { headers: { Authorization: `token ${token}` } })
            ]);
            if (!marketFileRes.ok || !pricesFileRes.ok) throw new Error("Could not get file contents.");
            const marketFileData = await marketFileRes.json();
            const pricesFileData = await pricesFileRes.json();
            const marketItems = JSON.parse(atob(marketFileData.content));
            const pricesLines = atob(pricesFileData.content).split('\n');

            // 3. Prepare updated market.txt content
            const newStatus = document.getElementById('publicStatusToggle').checked;
            const itemIndex = marketItems.findIndex(i => i.id === itemId);
            if (itemIndex === -1) throw new Error('Item not found in market.txt');
            marketItems[itemIndex].public = newStatus;
            const updatedMarketContent = JSON.stringify(marketItems, null, 4);

            // 4. Prepare updated mprices.txt content
            const newMarketPrice = document.getElementById('marketPriceInput').value;
            const newNpcPrice = document.getElementById('npcPriceInput').value;
            if (newMarketPrice === '') { showToast('Market Price is required.', 'error'); return; }
            
            const priceLineIndex = pricesLines.findIndex(l => l.startsWith(itemId + ':'));
            const priceArray = [itemId, parseInt(newMarketPrice), newNpcPrice === '' ? null : parseInt(newNpcPrice)];
            const newLine = `${itemId}: ${JSON.stringify(priceArray)}`;
            if (priceLineIndex > -1) {
                pricesLines[priceLineIndex] = newLine;
            } else {
                pricesLines.push(newLine);
            }
            const updatedPricesContent = pricesLines.join('\n');

            // 5. Create blobs for the new file contents
            const newTree = [];
            const marketBlobRes = await fetch(`https://api.github.com/repos/${GITHUB_REPO}/git/blobs`, {
                method: 'POST', headers: { 'Authorization': `token ${token}` },
                body: JSON.stringify({ content: updatedMarketContent, encoding: 'utf-8' })
            });
            const marketBlobData = await marketBlobRes.json();
            newTree.push({ path: MARKET_FILE_PATH, mode: '100644', type: 'blob', sha: marketBlobData.sha });

            const pricesBlobRes = await fetch(`https://api.github.com/repos/${GITHUB_REPO}/git/blobs`, {
                method: 'POST', headers: { 'Authorization': `token ${token}` },
                body: JSON.stringify({ content: updatedPricesContent, encoding: 'utf-8' })
            });
            const pricesBlobData = await pricesBlobRes.json();
            newTree.push({ path: PRICES_FILE_PATH, mode: '100644', type: 'blob', sha: pricesBlobData.sha });

            // 6. Create a new tree with the new blobs
            const treeRes = await fetch(`https://api.github.com/repos/${GITHUB_REPO}/git/trees`, {
                method: 'POST', headers: { 'Authorization': `token ${token}` },
                body: JSON.stringify({ base_tree: baseTreeSha, tree: newTree })
            });
            const treeData = await treeRes.json();
            const newTreeSha = treeData.sha;

            // 7. Create the new commit
            const commitMessage = `Update item ${itemId} by ${userName}`;
            const newCommitRes = await fetch(`https://api.github.com/repos/${GITHUB_REPO}/git/commits`, {
                method: 'POST', headers: { 'Authorization': `token ${token}` },
                body: JSON.stringify({ message: commitMessage, tree: newTreeSha, parents: [latestCommitSha] })
            });
            const newCommitData = await newCommitRes.json();
            const newCommitSha = newCommitData.sha;

            // 8. Update the branch reference to point to the new commit
            await fetch(`https://api.github.com/repos/${GITHUB_REPO}/git/refs/heads/${GITHUB_BRANCH}`, {
                method: 'PATCH', headers: { 'Authorization': `token ${token}` },
                body: JSON.stringify({ sha: newCommitSha })
            });

            showToast('All changes saved successfully!', 'success');
            document.getElementById('price-modal').style.display = 'none';
            setTimeout(() => location.reload(), 1500);

        } catch (error) {
            console.error('Error updating details:', error);
            showToast(`Error: ${error.message}`, 'error');
        }
    }

    function showToast(message, type = 'info') {
        const toast = document.createElement('div');
        toast.className = `toast-notification ${type}`;
        toast.textContent = message;
        document.body.appendChild(toast);
        setTimeout(() => { toast.classList.add('show'); }, 100);
        setTimeout(() => { toast.classList.remove('show'); setTimeout(() => toast.remove(), 500); }, 4000);
    }

    function formatPrice(price) { if (price === "N/A" || price === "NAN" || price === null || price === undefined) { return `<span class="item-price-img">N/A</span>`; } return `<span class="item-price-img">${Number(price).toLocaleString()} <img src="img/coin.png"></span>`; }
    function goToPrevItem() { const urlParams = new URLSearchParams(window.location.search); let id = parseInt(urlParams.get("item"), 10); if (isNaN(id) || id <= 1) return; if (isDevUser) { window.location.href = `item.html?item=${id - 1}`; } else { let prevId = id - 1; while (prevId > 0) { const prevItem = allItems.find(i => i.id == prevId); if (prevItem && (prevItem.public === undefined || prevItem.public)) { window.location.href = `item.html?item=${prevId}`; return; } prevId--; } } }
    function goToNextItem() { const urlParams = new URLSearchParams(window.location.search); let id = parseInt(urlParams.get("item"), 10); if (isNaN(id)) return; if (isDevUser) { window.location.href = `item.html?item=${id + 1}`; } else { let nextId = id + 1; while (nextId <= allItems.length + 1000) { const nextItem = allItems.find(i => i.id == nextId); if (nextItem && (nextItem.public === undefined || nextItem.public)) { window.location.href = `item.html?item=${nextId}`; return; } nextId++; } } }
    document.getElementById("prevItemBtn").addEventListener("click", goToPrevItem);
    document.getElementById("nextItemBtn").addEventListener("click", goToNextItem);
    async function initializePage() { await loadProfileCard(); await fetchAllItems(); await loadItemDetails(); }
    initializePage();
  </script>
</body>
</html>
